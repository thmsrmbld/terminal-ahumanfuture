---
title: Your software is rotting
date: 2025-03-18
nowPlaying: Vinegar Hill, by Elijah Fox
audioLink: ""
tags:
  - software
  - management
  - long-read
  - featured
description: The bad news is that your software is rotting. The good news is that there are many, many things you can do to slow the process to a crawl.
published: false
featured: false
---

{{ description }}

[//]: # '<img alt="test" src="/"/>'
[//]: # '<div class="padded-top">[Photo by <a href="/">TODO</a>]</div>'

TODO - Table of contents (needs styling)
TODO - Sharing tools (Email, BSky, WhatsApp, LinkedIn (this should go in base template for post.njk)

## Your software is rotting.

Recently I cannot shake the feeling that all software is rotting from the inside out like something organic in a garden
when you leave it to the order of the natural world. I think this is because software is just a frozen-in-time set of
solutions to problems constantly changing around us, which is why it's so important to software that is simple to change.

Code is a model; and as the saying goes:

<blockquote>All models are wrong. Some models are useful.</blockquote>

Large (web) codebases in 2025 are scaffolding around the business problem(s) that they're made to solve. And how a
codebase is built is a representation of the order of which it is born; the difficult problem space and all of its ugly
and lucrative incentives.

The basis and contradiction of this type of extant decay is that it is simultaneously easier and more difficult than ever to build software for the Internet. The component
parts of any non-trivial web application (user interface, application logic, data storage, distribution, and deployment) are complex by nature and all,
themselves, an ongoing concern - built on changing browsing, computing, security, accessibility and developer experience requirements. Your choice to
even make any foundational technology choices _at all_ grants you an inheritance, that like all great injustices, _are not_ your fault but _are_ your responsibility.
Before you write a line of your _own_ code you're _already_ choosing a world of pest-control. Unless you write everything alone, from the ground up, which is
so perverse an idea as to be impossible in practice.

<hr>

**So**, I think that software begins to rot at the moment it is conceived in the brain of anyone ambitious enough to attempt to get
a computer to do something sensible. Of course, our individual ability to instruct a computer to do something sensible is determined almost entirely by
our individual ability to truly understand a) what _sensible_ is and b) how to actually execute on that. This is the same reason that we
all write bugs, and that we all need teams. Instructing computers with languages sometimes feels to me almost perfectly incompatible with what most
human brains are designed to do well, and is incidentally why natural language AI interfaces already represent such a revolution in Human Computer Interaction.
Which is precisely _why_ we need many types of brain on engineering teams to counter, joust, and support each other. My brain, for example, is
calibrated perfectly to drinking comically strong mojitos on a beach with my friends, eating Korean food and playing the bass guitar in a punk band.
Which is about as far away from wrestling with the various exotic computing mysteries that live inside the NPM ecosystem as one might possibly imagine;
and so how I managed to make it this TODO far is fascinating, even to me.

So. The bad news is that your new software began to rot before you laid a line of code into your IDE. The good news is that you now already know that; and
as such, are ahead of the problem, and there are many highly effective things you can do to control its pace and nature. If you can take care of all of
them, you might _even_ slow it to a less than noticeable crawl. As with all guidance, these things are better executed as prevention rather than cure, but
I think you can retrofit a lot of these quite simple ideas even if you're already a long way down the road.

These ideas came to me in three categories: **Foundations**, **Workflow** and **Maintenance**.

<hr>

### Foundations

When I say 'foundations', I mean: TODO

#### Choose 'boring' technology

We made the mistake of using 'boring' as a synonym for 'stable' and that is a category error that I am determined to help reframe.
Boring is made of multiple things
Boring is circular and eventually, becomes exciting
Excitement creates potential

#### Automate the tedious

#### Choose good managers

Managing and distributing must be stable and predictable
It is not valuable to constantly screw with the meta process around software developmemt
We must solve for this at a low-level to unlock as much time as possible at all of the layers above it

### Workflow

When I say 'Workflow', I mean: TODO

#### Make it easy to do the right thing

#### A workflow is also a model, and it must be shared, and it must be changeable

#### Have policy for high-risk operations

#### Have machine-enforced patterns

Linting, code-style, approaches, formalised software design approach. What these are far less important than enforcing the consistency that they are designed to bring

#### Choose dependencies critically and defensively

Can I build this myself? Is there prior art? Does this _already exist in this codebase_? Dependencies evolve at a different pace than your software,
sometimes faster and sometimes slower. Getting stuck on a dependency automatically re-routes the resources you have for more valuable work

#### Choose the naturally co-operative

Building software is a team sport even if that team begins at one person and then grows.
The nature of the personalities recruited to your engineering teams must favour co-operating over the adversarial. Competition is good and different
than the adversarial but each member must exist as a force-multiplier wherever that is realistic.
We must all be champions

#### Leadership

Fountains are poisoned by one drop at the top. The things we drop at the top naturally filter down.

### Maintenance

When I say 'Maintenance', I mean:

Maintenance is deep and true hero-work that has never and will never be celebrated like the work of novelty (feature-work, etc). This is modelled in
society and political economy too.

####

Regular gardening, regular engine servicing, etc comparison
Technical debt: Pay down the principle. All debt must be serviced and we take debt of any kind to unlock the resources that accelerate our short-term future. Make time to minimise. Not all debt is bad and it is not a moral issue.

My basic view on technical debt is the result of making decisions that unlock large amounts of long-term opportunity at
the expense of short-term operational agility. Sometimes in software development we must make decisions that allow us
to move rapidly, knowing that the bill for that is always due eventually. We can do this in many ways (building hacks,
choosing to take on dependencies we didn't build at home,)

My thoughts on technical debt are the same as my thoughts on debt as a financial instrument:

1. Debt is not bad, nor a moral issue.
2. It is a miracle-drug for rapidly pulling the future towards you.
3. If you take it you must have a plan and method to pay it back down to nothing. Overpayment is critical.
4. The regular payment of the debt over time must not otherwise impede your freedom.
5. Long after the capital is gone, you are left with it's consequences, good and bad.

These opinions translate almost perfectly to my approach to technical debt, too. Sometimes you must make imperfect
decisions to create a platform for opportunity. Not taking on technical debt in these times is _it's own cost_. In an
industry where speed can a dominant variable in competition, remaining debt-free is often a bad choice that looks like
a good one.

### TODO

TODO

### TODO

TODO:

1. TODO
2. TODO

TODO

<hr>

TODO

Until tomorrow. ðŸ•¶ ðŸ–¤
